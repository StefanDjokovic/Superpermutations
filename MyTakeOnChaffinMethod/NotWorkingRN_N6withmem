#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

short max_perm;
short mperm_res[1000];
short tot_bl;

short cur_perm[4000];	//to 4000 just to be safe
short cur_best[4000];

short N;

bool* checker;
int* factval;
int* upper;
int* power;
short* connected1;
short* connected2;
short* connected3;
short* connected4;
short* connected5;
short* reverseconnected1;
short* reverseconnected2;
short* reverseconnected3;
short* reverseconnected4;
short* reverseconnected5;
bool* arr;
short stopit;
short stopitover;
short dong[3];
short dong2[4];
short minim;


int factorial(int k);

int getHashValue2(int* string) {
	long int val = 0;
	for (int i = 0; i < N; i++) {
		val = val * N + string[i];
	}
	val = upper[val];

	return val;
}

//this is the starting fillStr call
void fillStr0(short int pos, short int pfound, short int hashValue, short int waste) {
	cur_perm[pos] = hashValue;
	if (pfound > max_perm) {
		max_perm = pfound;
		for (int i = 0; i <= pos; i++) {
			cur_best[i] = cur_perm[i];
		}
	}

	if (max_perm < stopit && max_perm < stopitover) {
		int minihash = hashValue;
		int tempwaste;
		checker[minihash] = 1;
		int pfound2 = pfound + 1;
		int pos4 = pos + 4;
		int pos5 = pos + 5;

		//Making unwasted characters
		hashValue = connected1[minihash];
		if (checker[hashValue] == 0)
			fillStr0(pos + 1, pfound2, hashValue, waste);
		tempwaste = waste - 1;
		if (tempwaste >= 0 && mperm_res[tempwaste] + pfound > max_perm && mperm_res[tempwaste] + pfound >= minim) {
			hashValue = connected2[minihash];
			if (checker[hashValue] == 0)
				fillStr0(pos + 2, pfound2, hashValue, tempwaste);
			tempwaste--;
			if (tempwaste >= 0 && mperm_res[tempwaste] + pfound > max_perm && mperm_res[tempwaste] + pfound >= minim) {
				hashValue = connected3[minihash];
				if (checker[hashValue] == 0)
					fillStr0(pos + 3, pfound2, hashValue, tempwaste);
				hashValue++;
				if (checker[hashValue] == 0)
					fillStr0(pos + 3, pfound2, hashValue, tempwaste);
				tempwaste--;
				if (tempwaste >= 0 && mperm_res[tempwaste] + pfound > max_perm && mperm_res[tempwaste] + pfound >= minim) {
					hashValue = connected4[minihash];
					if (checker[hashValue] == 0)
						fillStr0(pos4, pfound2, hashValue, tempwaste);
					hashValue++;
					if (checker[hashValue] == 0)
						fillStr0(pos4, pfound2, hashValue, tempwaste);
					hashValue++;
					if (checker[hashValue] == 0)
						fillStr0(pos4, pfound2, hashValue, tempwaste);
					hashValue++;
					if (checker[hashValue] == 0)
						fillStr0(pos4, pfound2, hashValue, tempwaste);
					hashValue++;
					if (checker[hashValue] == 0)
						fillStr0(pos4, pfound2, hashValue, tempwaste);
					hashValue++;
					if (checker[hashValue] == 0)
						fillStr0(pos4, pfound2, hashValue, tempwaste);

					tempwaste--;
					if (tempwaste >= 0 && mperm_res[tempwaste] + pfound > max_perm && mperm_res[tempwaste] + pfound >= minim) {
						hashValue = connected5[minihash];
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
						hashValue++;
						if (checker[hashValue] == 0)
							fillStr0(pos5, pfound2, hashValue, tempwaste);
					}
				}
			}

		}
		checker[minihash] = 0;
	}
	cur_perm[pos] = -1;
}

void fillStr1(short int pos, short int pfound, short int waste) {
	if (cur_perm[pos] != -1) {
		fillStr0(pos, pfound, cur_perm[pos], waste);
		checker[cur_perm[pos]] = 0;
		pfound--;
	}
	else
		waste--;
	pos--;
	if (pos != 0)
		fillStr1(pos, pfound, waste);
	else
		return;
}



int main()
{
	unsigned short int j0;

	printf("This tool will try to find the length of the shortest superpermutation on n symbols. Please enter n: 6");
	//scanf("%d", &N);

	N = 6;

	mperm_res[0] = N;

	//contains factorial values from 0! to N!
	factval = (int*)malloc((N + 1) * sizeof(int));
	for (int i = 0; i <= N; i++) {
		factval[i] = factorial(i);
	}

	stopit = factval[N];

	upper = (int*)calloc(pow(N, N + 1), sizeof(int)); //a bit excessive, to improve
	power = (int*)malloc(sizeof(int) * (N * 2 + 1));
	connected1 = (short*)malloc(sizeof(short) * factval[N]);
	connected2 = (short*)malloc(sizeof(short) * factval[N]);
	connected3 = (short*)malloc(sizeof(short) * factval[N]);
	connected4 = (short*)malloc(sizeof(short) * factval[N]);
	connected5 = (short*)malloc(sizeof(short) * factval[N]);
	reverseconnected1 = (short*)malloc(sizeof(short) * factval[N]);
	reverseconnected2 = (short*)malloc(sizeof(short) * factval[N]);
	reverseconnected3 = (short*)malloc(sizeof(short) * factval[N]);
	reverseconnected4 = (short*)malloc(sizeof(short) * factval[N]);
	reverseconnected5 = (short*)malloc(sizeof(short) * factval[N]);

	for (int i = 0; i < factorial(N); i++) {
		connected1[i] = 0;
		connected2[i] = 0;
		connected3[i] = 0;
		connected4[i] = 0;
	}

	//contains power values of 6 from 0 to N*2
	for (int i = 0; i <= N * 2; i++) {
		power[i] = pow(N, i);
	}

	arr = (bool*)malloc(N * sizeof(bool));
	for (int s = 0; s < N; s++)
		arr[s] = 0;

	int a;
	int step;
	int k;

	//connecting first order connections to hash values
	for (int i = 0; i < factorial(N); i++) {
		long int upperValue = 0;
		for (int s = 0; s < N; s++)
			arr[s] = 0;

		a = i / factval[N - 1];
		arr[a] = 1;
		upperValue = a;

		for (int j = 1; j < N; j++) {
			a = i % factval[N - j];
			step = a / factval[N - (j + 1)];

			k = 0;
			while (arr[k] == 1)
				k++;
			while (step != 0) {
				if (arr[k] != 1)
					step--;
				k++;
				while (arr[k] == 1)
					k++;
			}
			arr[k] = 1;
			upperValue = upperValue * N + k;

		}
		upper[upperValue] = i;

	}

	//generationg connected1 and connected2
	int* conn = (int*)malloc(sizeof(int) * (N + 2));
	for (int i = 0; i < factval[N]; i++) {
		for (int s = 0; s < N; s++)
			arr[s] = 0;

		a = i / factval[N - 1];
		arr[a] = 1;
		conn[0] = a;
		conn[N] = a;
		for (int j = 1; j < N; j++) {
			a = i % factval[N - j];
			step = a / factval[N - (j + 1)];

			k = 0;
			while (arr[k] == 1)
				k++;
			while (step != 0) {
				if (arr[k] != 1)
					step--;
				k++;
				while (arr[k] == 1)
					k++;
			}
			arr[k] = 1;
			conn[j] = k;
		}
		connected1[i] = getHashValue2(&conn[1]);
		reverseconnected1[connected1[i]] = i;
		conn[N] = conn[1];
		conn[N + 1] = conn[0];
		connected2[i] = getHashValue2(&conn[2]);
		reverseconnected2[connected2[i]] = i;
		conn[N] = conn[2];
		if (conn[0] < conn[1]) {
			conn[N + 1] = conn[0];
			conn[N + 2] = conn[1];
		}
		else {
			conn[N + 1] = conn[1];
			conn[N + 2] = conn[0];
		}
		connected3[i] = getHashValue2(&conn[3]);
		reverseconnected3[connected3[i]] = i;

		conn[N] = conn[3];
		if (conn[0] < conn[1]) {
			if (conn[0] < conn[2]) {
				conn[N + 1] = conn[0];
				if (conn[1] < conn[2]) {
					conn[N + 2] = conn[1];
					conn[N + 3] = conn[2];
				}
				else {
					conn[N + 2] = conn[2];
					conn[N + 3] = conn[1];
				}

			}
			else {
				conn[N + 1] = conn[2];
				conn[N + 2] = conn[0];
				conn[N + 3] = conn[1];
			}
		}
		else {
			if (conn[1] < conn[2]) {
				conn[N + 1] = conn[1];
				if (conn[0] < conn[2]) {
					conn[N + 2] = conn[0];
					conn[N + 3] = conn[2];
				}
				else {
					conn[N + 2] = conn[2];
					conn[N + 3] = conn[0];
				}
			}
			else {
				conn[N + 1] = conn[2];
				conn[N + 2] = conn[1];
				conn[N + 3] = conn[0];
			}
		}
		connected4[i] = getHashValue2(&conn[4]);
		reverseconnected4[connected4[i]] = i;

		conn[N] = conn[4];
		for (int k = 0; k < 4; k++)
			dong2[k] = conn[k];
		int kk;
		for (int k = 1; k < 4; k++)
			for (int j = k; j > 0 && dong2[j - 1] > dong2[j]; j--) {
				kk = dong2[j];
				dong2[j] = dong2[j - 1];
				dong2[j - 1] = kk;
			}
		for (int k = 0; k < 4; k++)
			conn[k + 1 + N] = dong2[k];
		connected5[i] = getHashValue2(&conn[5]);
		reverseconnected5[connected5[i]] = i;

	}
	checker = (bool*)malloc(sizeof(bool) * factval[N]);


	printf("Thanks for choosing N: %d, let's start!\n", N);

	max_perm = 1;

	for (tot_bl = 1; tot_bl <= 150; tot_bl++) {
		//max_perm = 1; I can keep the previous max_perm to speed things up

		for (int i = 0; i < factval[N]; i++) {
			checker[i] = 0;
			cur_perm[i] = -1;
		}

		checker[0] = 1;

		minim = mperm_res[tot_bl - 1] + 4;
		stopitover = mperm_res[tot_bl - 1] + 6;

		fillStr0(N, 1, 0, tot_bl);
		mperm_res[tot_bl] = max_perm;

		printf("%d wasted characters: at most %d permutations\n", tot_bl, max_perm);

		if (max_perm >= factval[N]) {
			printf("\n-----\nDONE!\n-----\n\nMinimal superpermutations on %d symbols have %d wasted characters and a length of %d.\n", N, tot_bl, max_perm);
			break;
		}
		
		int place;
		int found = 0;
		for (int i = 0; i < 4000; i++) {
			if (cur_best[i] != -1) {
				cur_perm[i] = cur_best[i];
				checker[cur_perm[i]] = 1;
				place = i;
				found++;
			}
		}

		fillStr1(place, found, 1);

	}

	getchar();
	return 0;
}

// this function computes the factorial of a number
int factorial(int val) {
	int res = 1;
	for (int i = 1; i <= val; i++) {
		res = res * i;
	}
	return res;
}
